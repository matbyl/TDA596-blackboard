include api.repy
include neighbors.repy
include handlers.repy
include logicalClock.repy
include httprequest.repy
include node_voting.repy
include byzantine_behavior.repy

# ------------------------------------------------------------------------------
# Start listening and handle incoming connections to the application
# ------------------------------------------------------------------------------
def start_application():
  ip = mycontext['ip']
  port = mycontext['port']

  print "Listening on IP " + str(ip) +" port " + str(port)
  try:
    listencommhandle = waitforconn(ip, port, connection_handler)
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    raise
    #pass

# ------------------------------------------------------------------------------
# Called when an incoming message is received.
# ------------------------------------------------------------------------------
def connection_handler(ip, port, socketobj, thiscommhandle, listencommhandle):
  try:
    # Make sure that the response is not bigger than max allowed package size
    SOCKET_MAX_SIZE = 10000
    msgheader = socketobj.recv(1024)

    httpRequest = HttpRequest()
    httpRequest.parse(msgheader)

    # print httpRequest.get_info()

    write_methods = ['POST', 'PUT', 'DELETE']
    method = httpRequest.method
    endpoint = httpRequest.uri
    host = httpRequest.get_host()


    if msgheader.startswith('vote'):
      first_vote_handler(host,method)
    if msgheader.startswith('round2'):
      second_vote_handler(host,msgheader)


    if msgheader.startswith('byzantine'):
      mycontext['nodes'].get(host).set_general_status('Traitor')
      check_byzantine()
    #if not isHost(host):
       #print "received from host host "+str(host)
       #for key, node in mycontext['nodes'].iteritems():
        # print "status:"+str(node)


    parameters = httpRequest.get_parameters()
    res = ''
    status = 0
    if method == 'GET':
        # We do not support favicon's
        if endpoint == "/favicon.ico":
          return
        res, status = get_handler(endpoint)


    # React depending on message type: HTTP GET or POST, or some other type of communication.
    elif method == 'POST':
      res, status = post_handler(endpoint, httpRequest)

    elif method == 'PUT':
      res, status = mycontext['api'].put(endpoint, httpRequest)
      
    elif method == 'DELETE':
      res, status = mycontext['api'].delete(endpoint, httpRequest)

    if res and len(res) < SOCKET_MAX_SIZE:
      socketobj.send(res)

    stopcomm(thiscommhandle)
    
  except Exception, e:
    print "\nException in board: %s, %s" %(type(e), e)

# ------------------------------------------------------------------------------
# Broadcast the node's votes to neighboring nodes
# ------------------------------------------------------------------------------
def broadcast_my_vote():
  if mycontext['vote_broadcasted']==False:
    mycontext['vote_broadcasted']=True
    if mycontext['generalstatus']=='Honest':
      httpmessage = build_request_msg("vote:"+str(mycontext['myvote']))
      send_message(httpmessage)
    elif mycontext['generalstatus']=='Traitor':
      #do the byzantine#
      byzantine_votes = compute_byzantine_vote_round1(len(mycontext['nodes']) - no_of_traitor_nodes(),len(mycontext['nodes']), True)
      random=(randomfloat() * 10)
      if random < 5:
          mycontext['myvote'] = True
      else:
          mycontext['myvote'] = False
      # sets the vote of the current byzantine node randomly to true or false
      current_node = mycontext['nodes'].get(get_host())
      current_node.set_node_vote(mycontext['myvote'])
      send_byzantine_vote(byzantine_votes,"vote:")

# ------------------------------------------------------------------------------
# Broadcast the node's vector to neighboring nodes
# ------------------------------------------------------------------------------
def broadcast_second_vote():
  if mycontext['vector_broadcasted'] == False:

    if mycontext['generalstatus'] == 'Honest':
      votes = get_vote_vector()
      current_node = mycontext['nodes'].get(get_host())
      current_node.set_received_vector(votes)
      httpmessage = build_request_msg("round2:" + str(votes))
      mycontext['vector_broadcasted'] = True
      send_message(httpmessage)

    elif mycontext['generalstatus'] == 'Traitor':
      # do the byzantine#
      votes = compute_byzantine_vote_round2(len(mycontext['nodes']) - no_of_traitor_nodes(),len(mycontext['nodes']), True)

      mycontext['vector_broadcasted'] = True
      send_byzantine_vote(votes,"round2:")

# ------------------------------------------------------------------------------
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens a socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # DEFINE GLOBALS
  mycontext['startTime'] = getruntime();
  mycontext['lock'] = getlock()

  mycontext['api'] = Api()
  mycontext['api'].add_resource({'GET': get_index}, ['/'])
  mycontext['api'].add_resource({'GET': get_result}, ['/result'])
  mycontext['api'].add_resource({'POST': vote}, ['/vote'])

  # whenever this vessel gets a connection on its IP:port it'll call function board_connection_handler
  if len(callargs) == 1 or len(callargs) == 2:
    port = int(callargs[0])
    if len(callargs) == 2:
      ip=str(callargs[1])
    else:
      try:
        ip = getmyip()
      except Exception, e:
        print "Could not get an IP\n"
        print (type(e), e)
        raise

  # Fail if we don't have 1 or 2 arguments
  else:
    raise Exception("Usage: python <path to repy.py> <path to restrictions.default> main.repy <port> [ip (optional)]")

  #Initialize Port and IP
  mycontext['ip'] = ip
  mycontext['port'] = port
  mycontext['connection'] = Connection(ip, port)
  mycontext['myvote']=None
  mycontext['generalstatus']=None
  mycontext['vote_broadcasted'] = False
  mycontext['vector_broadcasted'] = False
  # Assign a random ID to the vessel between 0-100000 
  # NOTE: There is nothing that promise a unique ID
  mycontext['vesselID'] = str(int(100000 * randomfloat()))

  # Nearest neighbor of the current host
  mycontext['neighbors'] = get_all_neighbors()

  mycontext['host_index']=None
  mycontext['nodes']=get_all_nodes()


  # we need the host before we initialize the logicalClock
  mycontext['clock'] = LogicalClock()

  # variables that monitor the number of received votes and vector
  mycontext['votesreceived']=0
  mycontext['vectorreceived'] = 0

  mycontext['myresult']=None
  #read html template files
  mycontext['vote_frontpage_template'] = open("vote_frontpage_template.html").read()
  mycontext['vote_result_template'] = open("vote_result_template.html").read()
  
  # Cool dudes!
  mycontext['authors'] = "Mathias Bylund, Anton Rose"

  start_application()
