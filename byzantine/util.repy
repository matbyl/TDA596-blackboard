"""
 Util module

 Description: This module should contain functions that are useful in several
 cases.
 
"""


# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------


def make_http_response(status, status_text, htmlresponse=''):
  response_template = "HTTP/1.1 %d %s\r\nContent-type: text/html;charset=UTF-8\r\nContent-length: %s\r\n\r\n%s"
  res = response_template % (status, status_text, str(len(htmlresponse)), htmlresponse)
  return (res, status)

# ------------------------------------------------------------------------------
#  Creates a 404 response to display in HTTP request
# ------------------------------------------------------------------------------
def make_404_response(msgheader):
  # Do not mix HTML code with the server code as done here. This is a bad practice
  template = '<html><head><style>.status {color: red;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
  htmlresponse = template % ("404 Not Found\n" + msgheader)
  res = make_http_response(404, 'Not Found', htmlresponse)

# ------------------------------------------------------------------------------
#  Creates a 404 response to display in HTTP request
# ------------------------------------------------------------------------------
def make_post_request(msgheader, entry):
  template = '{"entry": %s}'
  htmlresponse = template % entry
  return make_http_response(200, 'OK', htmlresponse)

# ------------------------------------------------------------------------------
# Outputs the blackboard html
# ------------------------------------------------------------------------------
def generate_html_page():

  # dynamic title showing Ip address, port and up time.
  fullpage = mycontext['vote_frontpage_template']
  
  return fullpage

# ------------------------------------------------------------------------------
# Utility function to parse an endpoint
# ------------------------------------------------------------------------------
def parse_endpoint(endpoint):
  parts = endpoint.split('/')
  return {
    "resource": "/" + parts[0],
    "id": parts[1]
  }


def send_message(httpmessage):
  print "sending message"
  for key, node in mycontext['nodes'].iteritems():
    connection=node.get_node_connection()
    if not isHost(connection.get_host()):
      connection.send_msg(httpmessage)

def calculate_voting_result():
  print "calculating voting results"
  result_list=[]
  nodes= mycontext['nodes']
  index=0

  while(index< len(nodes)):

    voting_vector=[]
    vote_ignore_index = -1
    for key,node in nodes.iteritems():
      vote_ignore_index=vote_ignore_index+1
      votes=node.get_received_vote()
      if index!=vote_ignore_index:
        voting_vector.append(votes[index])
    #print "index"+str(index )
    result_list.append(calculate_max_votes_in_list(voting_vector))
    index = index + 1

  return result_list

# Process the vote vector
# input: vote list to process
# output: result of voting

def calculate_max_votes_in_list(vote_list):
  num_of_true=vote_list.count(True)
  num_of_false=vote_list.count(False)
  if num_of_true>num_of_false:
    return True
  elif num_of_false>num_of_true:
    return False
  else:
    return 'Unknown'

def send_byzantine_vote(byzantine_votes,message):

  print "byzantinne votes: "+str(byzantine_votes)
  index = -1
  for key, node in mycontext['nodes'].iteritems():
    connection = node.get_node_connection()
    if not isHost(connection.get_host()):
      index = index + 1;
      httpmessage = build_request_msg(message+str(byzantine_votes[index]))
      print "sending "+str(message)+" to port"+str(connection.port)
      connection.send_msg(httpmessage)


def isHost(host):
  thisHost = get_host()
  return thisHost == host

def get_host():
  return str(mycontext['ip']) + ":" + str(mycontext['port'])


def parse_received_vector(msgheader):
  message=msgheader.split('\n', 1)[0]
  start = message.find("[")
  end = message.find("]")
  vector = message[start:end]
  vector = vector.replace("[", "")
  vector = vector.replace("]", "")
  vector = vector.replace(",", " ")
  parsed_vector=vector.split()
  return parsed_vector

def build_request_msg(mainmessage):
  return mainmessage+" /None/ HTTP/1.1\r\nHost: " + mycontext['ip'] + ":" + str(
    mycontext['port']) + "\r\nConnection: Close\r\n"

# ------------------------------------------------------------------------------
# Retrieves vote vector
# ------------------------------------------------------------------------------
def get_vote_vector():
  received_vector=[]
  
  for key, node in mycontext['nodes'].iteritems():
      received_vector.append(node.get_node_vote())

  return received_vector