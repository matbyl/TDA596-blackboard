"""

  Name: handlers.repy
  Description: Handlers for all the requests

"""
include util.repy

def get_handler(endpoint):
    # if any thread has entered the election , then do nothing
    # if not trigger the election from this thread

    # ping nearest neighbor ,
    # if alive then start the election and release lock
    # if not alive , ping next nearest neighbor
    # repeat
  return mycontext['api'].get(endpoint)

def post_handler(endpoint, httpRequest):
  parameters = httpRequest.get_parameters()
  if parameters.has_key('delete'):
    if int(parameters['delete']) == 1:
      return mycontext['api'].delete(endpoint, httpRequest)
    else:
      return mycontext['api'].put(endpoint, httpRequest)
  else:
    return mycontext['api'].post(endpoint, httpRequest)

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_index():
  htmlresponse = generate_html_page()
  return make_http_response(200, 'OK', htmlresponse)

def get_result():
  htmlresponse = generate_html_page()
  return make_http_response(200, 'OK', htmlresponse)
  
def vote_attack(httpRequest):
  print "voted attack"
  mycontext['lock'].acquire()
  mycontext['generalstatus']='Honest'
  mycontext['nodes'].get(get_host()).set_general_status(mycontext['generalstatus'])
  if mycontext['myvote']==None:
    print "broadcasted only once"
    mycontext['myvote'] = True
    mycontext['nodes'].get(get_host()).set_node_vote(mycontext['myvote'])
    broadcast_my_vote()

  mycontext['lock'].release()
  pass
  
def vote_retreat(httpRequest):
  print "voted retreat"
  mycontext['lock'].acquire()
  mycontext['generalstatus'] = 'Honest'
  mycontext['nodes'].get(get_host()).set_general_status(mycontext['generalstatus'])
  if mycontext['myvote'] == None:
    print "broadcasted retreat only once"
    mycontext['myvote'] = False
    mycontext['nodes'].get(get_host()).set_node_vote(mycontext['myvote'])
    broadcast_my_vote()

  mycontext['lock'].release()
  pass
  
def vote_byzantine(httpRequest):
  print "voted byzantine"
  mycontext['generalstatus'] = 'Traitor'
  mycontext['nodes'].get(get_host()).set_general_status(mycontext['generalstatus'])
  httpmessage = build_request_msg("byzantine")
  send_message(httpmessage)
  check_byzantine()
  pass

# method to calculate the number of traitor nodes
# only byzantine nodes use this method
def no_of_traitor_nodes():
    traitor_nodes = 0
    for key, node in mycontext['nodes'].iteritems():
        if node.get_general_status() == 'Traitor':
            traitor_nodes = traitor_nodes + 1

    return traitor_nodes

def check_byzantine():

    print "\n number of traitor nodes"+str(no_of_traitor_nodes())
    if mycontext['generalstatus'] == 'Traitor' and mycontext['votesreceived'] == (len(mycontext['nodes']) - no_of_traitor_nodes()):
      print "vote received in traitor to broadcast"+str(len(mycontext['nodes']))
      if mycontext['vote_broadcasted'] == False:
        broadcast_my_vote()
    elif mycontext['generalstatus'] == 'Traitor' and mycontext['votesreceived'] < (len(mycontext['nodes']) - no_of_traitor_nodes()):
      print "waiting for other node's votes to broadcast"



def create_vote_vector():

    received_vector=[]
    if mycontext['generalstatus'] == 'Honest':
      for key, node in mycontext['nodes'].iteritems():
          received_vector.append(node.get_node_vote())
    elif mycontext['generalstatus'] == 'Traitor':
        received_vector=compute_byzantine_vote_round2(len(mycontext['nodes']) - no_of_traitor_nodes(), len(mycontext['nodes']), True)

    return received_vector
# ------------------------------------------------------------------------------
# Creates and adds a new entry to the global variable entries
# ------------------------------------------------------------------------------
def add_entry(httpRequest):
  try:
    parameters = httpRequest.get_parameters()


    print parameters
    msgid =  int(parameters['id'])

    if not msgid in mycontext['entries']:
        msg = parameters['entry']
        timestamp = parameters['timestamp']

        mycontext['lock'].acquire()
        mycontext['entries'][msgid] = Entry(msgid, msg, timestamp, httpRequest.get_host())
        mycontext['lock'].release()

        return make_http_response(201, 'Created', "Added new entry! <br />ID: " + str(msgid) + "<br />Message: " + msg)
    else:
        return make_http_response(409, 'Conflict')

  except Exception, e:
    print "Unable to handle add_entry request %s, %s" %(type(e), e)


def remove_entry(msgid, httpRequest):
  try:
    parameters = httpRequest.get_parameters()

    if msgid in mycontext['entries']:

        # If the current request is historical we need to make sure that
        # deletion happened after the entry was created
        if 'history' in parameters and is_invalid_write(mycontext['entries'][msgid].get_timestamp(), parameters['history']):
            raise Exception();

        mycontext['lock'].acquire()
        del mycontext['entries'][msgid]
        mycontext['lock'].release()

        return make_http_response(200, 'OK', "Removed entry: " + str(msgid))
    else:
        return make_http_response(404, 'Not Found');

  except Exception:
    raise Exception("Unable to remove entry")

def modify_entry(msgid, httpRequest):
  try:
    parameters = httpRequest.get_parameters()
    msg = parameters['entry']

    if msgid in mycontext['entries']:

        # If history is older then the current update value do not modify the entry
        if 'history' in parameters and is_invalid_write(mycontext['entries'][msgid].last_update(), parameters['history']):
            raise Exception()

        mycontext['lock'].acquire()
        mycontext['entries'][msgid].update(msg, mycontext['clock'].get_timestamp())
        mycontext['lock'].release()

        return make_http_response(200, 'OK', "Modified entry: " + str(msgid))
    else:
        return make_http_response(404, 'Not Found');

  except Exception, e:
    print "Unable to modify entry, Error: %s" % e


def first_vote_handler(host,method):
    node = mycontext['nodes'].get(host)
    # if vote of the node is not set then its a fresh vote and we add 1 to the received votes
    # this number will be used by the byzantine node to know whether it has received all the votes from the loyal nodes
    mycontext['lock'].acquire()
    if node.node_vote == None:
        mycontext['votesreceived'] = mycontext['votesreceived'] + 1
        node.set_node_vote(method.split(':')[1])
    if node.get_general_status() == None:
        node.set_general_status('Honest')

    mycontext['lock'].release()
    check_byzantine()
    if mycontext['votesreceived'] == len(mycontext['nodes']) - 1:
        print "time to send next vecctors"

        broadcast_second_vote()

def second_vote_handler(host,msgheader):
    node = mycontext['nodes'].get(host)
    firstline = msgheader.split('\n', 1)[0]
    vector = parse_received_vector(firstline)
    mycontext['lock'].acquire()

    if node.get_received_vote() == None:
        mycontext['vectorreceived'] = mycontext['vectorreceived'] + 1
        node.set_received_vector(vector)
        print "\nreceived from " + str(host) + " vectornumber : " + str(mycontext['vectorreceived'])
        if mycontext['vectorreceived'] == len(mycontext['nodes']) - 1:
            for key, port in mycontext['nodes'].iteritems():
                port.print_received()
    mycontext['lock'].release()