include util.repy

# ------------------------------------------------------------------------------
# Retrieves all the neighbors
# ------------------------------------------------------------------------------
def get_all_neighbors():
  f = open('neighborlist.txt')
  neighbors = []
  port =  mycontext['port']
  hostIndex = 0
  neighborIndex=0
  for line in f.readlines():

    # only asasume we have a port when working locally
    if mycontext['ip'] == "127.0.0.1":
      ip = line.split(":")[0]
      port = int(line.split(":")[1])
    else:
      ip = line.strip('\n')

    print '-------------------------'
    print 'I AM: ' + str(mycontext['ip']) + ':' + str(mycontext['port'])
    print '-------------------------'

    host = get_host(ip, port)
    hostIndex+ = 1
    # Do not include current host (or int(data[1]) != mycontext['port'])
    if not isHost(host):
      print '-------------------------'
      print 'U R: ' + str(ip) + ':' + str(port)
      print '-------------------------'

      neighbors.append(Neighbor(ip, port))
    else:
    # After identifying the host we find the neighbor index
      neighborIndex=hostIndex

  mycontext[nearestNeighbor]=get_nearest_neighbor(neighborIndex,neighbors)

  return neighbors

# ------------------------------------------------------------------------------
# Retrieves the next available neighbor from the ring, when the neighbor index is
#  bigger than the available neighbors it will reset the index to zero (ring topology)
#  #TODO  handling the failure node case
# ------------------------------------------------------------------------------
def get_nearest_neighbor(neighborIndex,neighbors):
  neighbor=None
  if neighborIndex > len(neighbors):
    neighborIndex=0

  return neighbors[neighborIndex]

class Neighbor:

  def __init__(self, ip, port):
    self.ip = str(ip)
    self.port = int(port)

  def send_msg(self, msg):
    connection = openconn(self.ip, self.port)
    connection.send(msg)
    connection.close()
