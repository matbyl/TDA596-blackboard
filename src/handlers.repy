# Handler module

include util.repy
include uniqueid.repy

def get_handler(endpoint):
    # if any thread has entered the election , then do nothing
    # if not trigger the election from this thread

    # ping nearest neighbor ,
    # if alive then start the election and release lock
    # if not alive , ping next nearest neighbor
    # repeat

  return mycontext['api'].get(endpoint)



def post_handler(endpoint, parameters):


  if parameters.has_key('delete'):
    if int(parameters['delete']) == 1:
      return mycontext['api'].delete(endpoint)
    else:
      return mycontext['api'].put(endpoint, parameters)
  else:
    return mycontext['api'].post(endpoint, parameters)

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_board():
  htmlresponse = generate_html_page()
  return make_http_response(200, 'OK', htmlresponse)


# ------------------------------------------------------------------------------
# Creates and adds a new entry to the global variable entries
# ------------------------------------------------------------------------------
def add_entry(parameters):
  try:
    msg = parameters['entry']
    msgid = uniqueid_getid()
    print msgid
    entry = generate_entry(msgid, msg)
    mycontext['entries'][msgid] = entry


    return make_http_response(201, 'Created', "Added new entry! <br />ID: " + str(msgid) + "<br />Message: " + msg)

  except Exception:
    raise Exception("Unable to handle add_entry request")


def election_message_handler(message):
  #mycontext['lock'].acquire()


  print "election hanlder"
  initiator = parse_election_message(message,'Initiator:')

  leaderhost=parse_election_message(message,'Leader host:')
  leader_id = parse_election_message(message,'Leader Id:')

  print "\n Parsed election: initiator: " + initiator + " leaderhost: " + leaderhost + " leader_id : " + leader_id + "\n"

  # if the id of election message is small than our id , we will assign the election data with our details ,
  # else , assign leader from the message

  if leader_id > mycontext['election'].id:
    mycontext['lock'].acquire()
    mycontext['election'].leaderId=leader_id
    mycontext['election'].leader=leaderhost
    mycontext['lock'].release()
  else:
    mycontext['lock'].acquire()
    mycontext['election'].leaderId =mycontext['election'].id
    mycontext['election'].leader=get_host()
    mycontext['lock'].release()

  if initiator  != get_host():
    mycontext['lock'].acquire()
    #mycontext['election'].initiator=initiator
    mycontext['lock'].release()
    pass_election_data_to_neighbor(initiator,mycontext['election'].leader,mycontext['election'].leaderId)
    # send message to neighbor
  else:
    print "finish sending"
    mycontext['leader']=mycontext['election'].leader
    #assign leader based on message
    #no need to send
  #mycontext['lock'].release()
  print "\n My own id" + str(mycontext['election'].id)
  print "\n processed election: initiator: " + initiator + " leaderhost: " + str(mycontext['election'].leader) + " leader_id : " + str(mycontext['election'].leaderId) + "\n"


def remove_entry(msgid):
  try:
    del mycontext['entries'][msgid]
    return make_http_response(200, 'OK', "Removed entry: " + str(msgid))
  except Exception:
    raise Exception("Unable to remove entry")

def modify_entry(msgid, msg):
  try:
    mycontext['entries'][msgid] = generate_entry(msgid, msg)
    return make_http_response(200, 'OK', "Modified entry: " + str(msgid))
  except Exception:
    raise Exception("Unable to modify entry")