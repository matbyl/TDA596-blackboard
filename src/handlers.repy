# Handler module

include util.repy
include uniqueid.repy

def get_handler(endpoint):
    # if any thread has entered the election , then do nothing
    # if not trigger the election from this thread

    # ping nearest neighbor ,
    # if alive then start the election and release lock
    # if not alive , ping next nearest neighbor
    # repeat

  return mycontext['api'].get(endpoint)



def post_handler(endpoint, parameters):
  if parameters.has_key('delete'):
    if int(parameters['delete']) == 1:
      return mycontext['api'].delete(endpoint)
    else:
      return mycontext['api'].put(endpoint, parameters)
  else:
    return mycontext['api'].post(endpoint, parameters)

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_board():
  htmlresponse = generate_html_page()
  return make_http_response(200, 'OK', htmlresponse)


# ------------------------------------------------------------------------------
# Creates and adds a new entry to the global variable entries
# ------------------------------------------------------------------------------
def add_entry(parameters):
  try:
    mycontext['lock'].acquire()
    
    msg = parameters['entry']
    msgid = uniqueid_getid()
    print msgid
    entry = generate_entry(msgid, msg)
    mycontext['entries'][msgid] = entry

    mycontext['lock'].release()

    return make_http_response(201, 'Created', "Added new entry! <br />ID: " + str(msgid) + "<br />Message: " + msg)

  except Exception:
    raise Exception("Unable to handle add_entry request")


def election_message_handler(message):
  mycontext['lock'].acquire()
  
  initiator = parse_election_message(message,'Initiator:')
  leader_host = parse_election_message(message,'Leader host:')
  leader_id = parse_election_message(message,'Leader Id:')


  # if the id of election message is small than our id , we will assign the election data with our details ,
  # else , assign leader from the message
  if int(leader_id) < mycontext['election'].id:
    leader_id = str(mycontext['election'].id)
    leader_host = get_host()

  if initiator != get_host():
    print "\n===========================\nForwarding message!\n===========================\n"
    message = create_election_message(initiator, leader_host, leader_id)
    print message + "\n\n"

    mycontext['election'].neighbor.send_msg(message)
    # send message to neighbor
  else:
    print "\n===========================\nDeclared a new leader\nIP:" + leader_host + "\nID:" + leader_id + " \n===========================\n"
    ip = leader_host.split(":")[0].strip()
    port = leader_host.split(":")[1].strip()

    mycontext['leader'] = Connection(ip, port, 0)
    mycontext['leader'].leader = leader_host
    #assign leader based on message
    #no need to send

  mycontext['lock'].release()


def create_election_message( initiator, leader_host, leader_id):
  message = "Election \nInitiator: " + initiator + "\n"
  message += "Leader host: " + leader_host + "\n"
  message += "Leader Id: " + leader_id + "\n"
  return message

def remove_entry(msgid):
  try:
    mycontext['lock'].acquire()
    del mycontext['entries'][msgid]
    mycontext['lock'].release()
    return make_http_response(200, 'OK', "Removed entry: " + str(msgid))
    
  except Exception:
    raise Exception("Unable to remove entry")

def modify_entry(msgid, msg):
  try:
    mycontext['lock'].acquire()
    mycontext['entries'][msgid] = generate_entry(msgid, msg)
    mycontext['lock'].release()
    return make_http_response(200, 'OK', "Modified entry: " + str(msgid))
   
  except Exception:
    raise Exception("Unable to modify entry")