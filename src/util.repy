# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Util module
#
# Description: This module should contain functions that are useful in several
# cases.
#
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_response(status, status_text, htmlresponse=''):
  response_template = "HTTP/1.1 %d %s\r\nContent-type: text/html;charset=UTF-8\r\nContent-length: %s\r\n\r\n%s"
  res = response_template % (status, status_text, str(len(htmlresponse)), htmlresponse)
  return (res, status)

# ------------------------------------------------------------------------------
#  Creates a 404 response to display in HTTP request
# ------------------------------------------------------------------------------
def make_404_response(msgheader):
  # Do not mix HTML code with the server code as done here. This is a bad practice
  template = '<html><head><style>.status {color: red;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
  htmlresponse = template % ("404 Not Found\n" + msgheader)
  res = make_http_response(404, 'Not Found', htmlresponse)

# ------------------------------------------------------------------------------
#  Creates a 404 response to display in HTTP request
# ------------------------------------------------------------------------------
def make_post_request(msgheader, entry):
  template = '{"entry": %s}'
  htmlresponse = template % entry
  return make_http_response(200, 'OK', htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
  # find content length
  try:
    content_length = header.split('Content-Length: ')[1]
    content_length = int(content_length.split('\r\n')[0])

    # extract the http response body and discard the header
    contents = header[-content_length:]
    return contents
  except Exception:
    return False

# ------------------------------------------------------------------------------
# Utility function to extract the value from a given header
# ------------------------------------------------------------------------------
def extract_http_request_header_value(headers, header):
  try:
    # Split on the color and extract the value part
    tail = headers.split(header.capitalize() + ': ')[1]
    # Strip newline and return only the value
    value = tail.split('\r\n')[0]

    # If no value is found we raise an excetion

    if value == []:
      raise Exception

    return value
  except Exception:
    print "Unable to extract" + header + " from http request"
    return False

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
  # extract the query parameters as a dictionary: {name:value}
  # example input format: comment=aa&ip=127.0.0.1&port=63101&action=Delete
  parameters={}
  arr = msg.split('&')
  for a in arr:
    pp = a.split('=')
    if len(pp)>1:
      parameters[pp[0]] = pp[1]
  return parameters

# ------------------------------------------------------------------------------
# Outputs the blackboard html
# ------------------------------------------------------------------------------
def generate_html_page():

  # dynamic title showing Ip address, port and up time.
  title='Host: %s:%d Elapsed time for eventual consistency: %d' %( str(mycontext['ip']), mycontext['port'], int(get_elapsed_time()) )
  content = mycontext['boardcontents_template'] %( title, "".join(generate_entries()))
  fullpage_h = mycontext['frontpage_header_template'] + content
  fullpage = fullpage_h + mycontext['frontpage_footer_template'] % mycontext['authors']
  #print entries, content, fullpage
  fullpage = ''.join(fullpage.split('\t'))
  return ''.join(fullpage.split('\n'))

# ------------------------------------------------------------------------------
# Retrieves all entries in a sorted fashion according to their given timestamp
# ------------------------------------------------------------------------------
def generate_entries():
  entry_objects = mycontext['entries'].values()
  entries = map(get_entry_html, sortEntries(entry_objects))
  return entries[-5:]

def get_sorted_entries():
  return sortEntries(mycontext['entries'].values())

def update_messages():
  mycontext['msgList'] = get_sorted_entries()

  #print '============================='
  #for msg in mycontext['msgList']:
  #  print msg
  #print "Number of entries: %d" % len(mycontext['msgList'])
  #print "Elapsed time: %d" % get_elapsed_time()
  # print '============================='


  mycontext['eventualConsistency'] = getruntime()
  mycontext['updatingMessages'] = False

# ------------------------------------------------------------------------------
# Helper function to map entry objects to a list with corresponding html-items
# ------------------------------------------------------------------------------
def get_entry_html(entry):
  return entry.get_html()

# ------------------------------------------------------------------------------
# Utility function to parse an endpoint
# ------------------------------------------------------------------------------
def parse_endpoint(endpoint):
  parts = endpoint.split('/')
  return {
    "resource": "/" + parts[0],
    "id": parts[1]
  }

def generate_entry(msgid, msg):
  return mycontext['entry_template'] % ('entries/%d' % (msgid), msgid, msg)

def isHost(host):
  thisHost = get_host()
  return thisHost == host

def get_host():
  return str(mycontext['ip']) + ":" + str(mycontext['port'])

# Primitive approach to handle failed requests
def check_history():
    # If there has been more than three modifications to the board we assume
    # that an incorrect call was made
    lifespan = 10
    oldHistory = []

    for key, httpRequest in mycontext['history'].iteritems():
        if is_old_history(key, lifespan):
            oldHistory = key
        else:
            mycontext['connection'].send_msg(httpRequest.get_request())

    for key in oldHistory:

        # Handle this as a critical section to prevent multiple threads
        # attempting to clear history at the same time
        mycontext['lock'].acquire();
        if key in mycontext['history']:
            del mycontext['history'][key]
        mycontext['lock'].release();

    mycontext['checkingHistory'] = False

def is_old_history(timestamp, lifespan):
    return int(timestamp) < int(mycontext['clock'].get_timestamp()) - lifespan

# Check to see if a write happened after the current timestamp on the entry
def is_invalid_write(c_timestamp, w_timestamp):
    return w_timestamp < c_timestamp

def sortEntries(entries):
    less  = []
    equal = []
    greater = []

    if len(entries) > 1:
        pivot = entries[0]

        for item in entries:
            if item.get_timestamp() < pivot.get_timestamp():
                less.append(item)
            elif item.get_timestamp() > pivot.get_timestamp():
                greater.append(item)
            elif item.get_timestamp() == pivot.get_timestamp():
                itemIp = int(item.get_host().split(':')[0].replace('.',''))
                pivotIp = int(item.get_host().split(':')[0].replace('.',''))

                if item.get_host() < pivot.get_host():
                  less.append(item)
                elif item.get_host() > pivot.get_host():
                  greater.append(item)
                # Should not come to this in our context, but we keep it here in case
                else:
                  equal.append(item)

        return sortEntries(less) + equal + sortEntries(greater)
    else:
        return entries

# ------------------------------------------------------------------------------
# Retrieve elapsed time since the start of the program
# ------------------------------------------------------------------------------
def get_elapsed_time():
  return mycontext['eventualConsistency'] - mycontext['startTime']