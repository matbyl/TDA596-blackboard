include api.repy
include neighbors.repy
include handlers.repy
include logicalClock.repy
include httprequest.repy

# ------------------------------------------------------------------------------
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------
def start_board():
  ip = mycontext['ip']
  port = mycontext['port']

  print "Listening on IP " + str(ip) +" port " + str(port)
  try:
    listencommhandle = waitforconn(ip, port, board_connection_handler)
  except Exception, e:
    print "Exception in start_board: %s, %s\n" %(type(e), e)
    raise
    #pass

# ------------------------------------------------------------------------------
# Called when an incoming message is received.
# --> Important starting point
# ------------------------------------------------------------------------------
def board_connection_handler(ip, port, socketobj, thiscommhandle, listencommhandle):
  try:
    msgheader = socketobj.recv(1024)

    httpRequest = HttpRequest()
    httpRequest.parse(msgheader)

    print httpRequest.get_info()

    write_methods = ['POST', 'PUT', 'DELETE']
    method = httpRequest.method
    endpoint = httpRequest.uri
    host = httpRequest.get_host()
    parameters = httpRequest.get_parameters()
    res = ''
    status = 0

    if method == 'GET':
        if endpoint != "/favicon.ico":
          res, status = get_handler(endpoint)

    # React depending on message type: HTTP GET or POST, or some other type of communication.
    elif method == 'POST':

      # We need to account for the timestamp of the message recieved
      if not isHost(host):
        mycontext['clock'].update(httpRequest.get_header('Host-Timestamp'))
      else:
        mycontext['clock'].tick()

      print mycontext['clock']

      # If there is not id for the entry yet we generate a new one
      # note that this also gets passed to the neighbors laters
      if not 'id' in parameters:
        httpRequest.add_parameter('id', mycontext['randomid'] + str(uniqueid_getid()))

      res, status = post_handler(endpoint, httpRequest)

    elif method == 'PUT':
      res, status = mycontext['api'].put(endpoint, httpRequest)
    elif method == 'DELETE':
      res, status = mycontext['api'].delete(endpoint)

    if res:
      print socketobj.send(res)
      # If new a event occurs we need to make a check with the history
      if method in write_methods and not 'history' in parameters:
          settimer(2, check_history, ())

    stopcomm(thiscommhandle)


    if isHost(host) and method in write_methods:
      httpRequest.add_header('Host-Timestamp', mycontext['clock'].get_timestamp())

      for neighbor in mycontext['neighbors']:
        neighbor.send_msg(httpRequest.get_request())

    if str(status)[:1] == '4' and isHost(host):

        if not 'history' in parameters:
            print "Http Response returned with Status Code: %d" % status
            print "Adding request to history"
            httpRequest.add_parameter('history', mycontext['clock'].get_timestamp())
            mycontext['history'][mycontext['clock'].get_timestamp()] = httpRequest

    elif str(status)[:1] == '2' and 'history' in parameters:
        del mycontext['history'][parameters['history']]


  except Exception, e:
    print "\nException in board: %s, %s" %(type(e), e)


# ------------------------------------------------------------------------------
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens a socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
  # DEFINE GLOBALS
  mycontext['entries'] = {}
  # dictionary that contains history in the case of a request failing
  mycontext['history'] = {}
  mycontext['lock'] = getlock()

  api = Api()

  handlers = {
    'GET': get_board
  }
  api.add_resource(handlers, ['/', '/board'])

  handlers = {
    'POST': add_entry,
    'DELETE': remove_entry,
    'PUT': modify_entry
  }
  api.add_resource(handlers, ['/entries'])

  mycontext['api'] = api

  # whenever this vessel gets a connection on its IP:port it'll call function board_connection_handler
  if len(callargs) == 1 or len(callargs) == 2:
    port = int(callargs[0])
    if len(callargs) == 2:
      ip=str(callargs[1])
    else:
      try:
        ip = getmyip()
      except Exception, e:
        print "Could not get an IP\n"
        print (type(e), e)
        raise

  # Fail if we don't have 1 or 2 arguments
  else:
    raise Exception("Usage: python <path to repy.py> <path to restrictions.default> main.repy <port> [ip (optional)]")

  #Initialize Port and IP
  mycontext['port'] = port
  mycontext['ip'] = ip
  mycontext['connection'] = Connection(ip, port)
  mycontext['randomid'] = str(int(10000 * randomfloat()))
  print mycontext['randomid']

  # Nearest neighbor of the current host
  mycontext['neighbors'] = get_all_neighbors()

  # we need the host before we initialize the logicalClock
  mycontext['clock'] = LogicalClock()

  #read html template files
  mycontext['entry_template'] = open("entry_template.html").read()
  mycontext['boardcontents_template'] = open("boardcontents_template.html").read()
  mycontext['frontpage_header_template'] = open("board_frontpage_header_template.html").read()
  mycontext['frontpage_footer_template'] = open("board_frontpage_footer_template.html").read()

  mycontext['authors'] = "Mathias Bylund, Anton Rose"

  start_board()
